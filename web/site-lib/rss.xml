<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[brain_obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>brain_obsidian</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 19 Dec 2025 12:26:38 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 19 Dec 2025 12:26:38 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[김영현  신입 개발자 포트폴리오]]></title><description><![CDATA[
이름: 김영현
생년월일: 2000년 05월 05일
이메일: <a data-tooltip-position="top" aria-label="mailto:kimyh9181@naver.com" rel="noopener nofollow" class="external-link is-unresolved" href="mailto:kimyh9181@naver.com" target="_self">kimyh9181@naver.com</a>
<br>GitHub: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/SuperNoobChallenge" target="_self">https://github.com/SuperNoobChallenge</a>
--ㅁㄹ?--
Programming Languages: Python: NumPy, OpenCV 등 라이브러리 활용 능력
PCCP Python 3 Lv.3 자격 보유 Java, C++: 객체 지향 프로그래밍 기본 이해
대학 수준의 프로젝트 구현 능력 Database: SQL: 기본적인 CRUD 쿼리 및 Join 문 작성 가능
JPA, JPQL: fetch join을 사용한 간단한 쿼리 최적화 가능 Cloud: Firebase (Firestore, Authentication) 활용 경험 Hardware &amp; IoT: ESP32 기반 시스템 구축 및 센서 데이터 처리 경험 Tools &amp; Collaboration: GitHub
Spring: Spring Boot를 활용해 간단한 웹 애플리케이션 구현 경험 1. 자세 추정 모델 기반 성인-아동 분류 (2023.06 ~ 2024.06)
설명: CCTV 등에서 신체 일부만 촬영되어도 성인과 아동을 효과적으로 분류하기 위해, 자세 추정(Pose Estimation) 모델로 추출한 신체 특징 데이터를 다층 퍼셉트론(MLP) 모델로 학습시켜 분류하는 시스템 개발. 기존 신체 비율 기반 분류 방식의 한계점 개선 시도.
나의 역할 및 기여: 데이터 수집 및 다양한 가림 시나리오를 적용한 데이터 증강 수행.
자세 추정 모델을 활용하여 17개 주요 관절/얼굴 좌표 및 Bounding Box 추출.
Bounding Box 기반 Min-Max Scaling으로 특징 정규화 및 관절 간 거리 계산을 통해 47차원 특징 벡터 생성.
MLP 모델 설계 (3개 은닉층, ReLU, Dropout) 및 하이퍼파라미터 튜닝을 통한 모델 학습 주도. 사용 기술: Python, Pose Estimation (YOLOv8-pose), NumPy, MLP (PyTorch).
결과/성과: 개발된 모델의 테스트 데이터셋 기준 분류 정확도 85% 달성.
<br>Link: <a data-tooltip-position="top" aria-label="https://shrub-ninja-35e.notion.site/1f0ea2da112281b6bfe2f9b663af6a24" rel="noopener nofollow" class="external-link is-unresolved" href="https://shrub-ninja-35e.notion.site/1f0ea2da112281b6bfe2f9b663af6a24" target="_self">Notion</a>
2. 인터넷 연결 스마트화분 (2024.07 ~ 2024.12)
설명: 기존 블루투스 기반 스마트 화분의 원격 모니터링 한계를 극복하고자, ESP32 마이크로컨트롤러와 Wi-Fi를 이용해 센서(온습도, 토양 습도, 배터리 전압) 데이터를 Firebase Firestore로 전송하고, 사용자가 모바일 앱을 통해 원격으로 식물 상태를 확인할 수 있는 IoT 시스템.
나의 역할 및 기여: 하드웨어(HW): ESP32 기반 시스템 설계 및 구축 (센서 연동, 데이터 전처리), Deep Sleep 모드를 활용한 전력 관리, Wi-Fi/Bluetooth 통신 구현 (데이터 전송, 앱 통한 Wi-Fi 설정).
데이터베이스(DB): 확장성을 고려한 NoSQL (Firestore) 스키마 설계 (사용자-화분-데이터 관계).
애플리케이션: Firestore 데이터 연동, ESP32 Wi-Fi 설정을 위한 Bluetooth 통신 기능 개발. 사용 기술: ESP32 (C++), Firebase (Firestore, Authentication), Android Studio (Kotlin), Sensors (DHT22, Soil Moisture, etc.).
결과/성과: 원격 식물 상태 모니터링 및 관리 시스템 프로토타입 완성 및 동작 시연. 초기 설계(라즈베리파이) 실패 경험을 통해 문제 분석 및 해결 능력 향상, 기술 선택(ESP32, Firebase)의 중요성 학습.
<br>Link: <a data-tooltip-position="top" aria-label="https://github.com/SuperNoobChallenge/smartpot_HW" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/SuperNoobChallenge/smartpot_HW" target="_self">GitHub Repository(HW)</a>, <a data-tooltip-position="top" aria-label="https://github.com/SuperNoobChallenge/smartpot" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/SuperNoobChallenge/smartpot" target="_self">GitHub Repository(APP)</a>, <a data-tooltip-position="top" aria-label="https://youtu.be/H9EMrdDH0d8" rel="noopener nofollow" class="external-link is-unresolved" href="https://youtu.be/H9EMrdDH0d8" target="_self">YouTube Demo</a>, <a data-tooltip-position="top" aria-label="https://shrub-ninja-35e.notion.site/1f0ea2da112281c995bfeab32f8e1854" rel="noopener nofollow" class="external-link is-unresolved" href="https://shrub-ninja-35e.notion.site/1f0ea2da112281c995bfeab32f8e1854" target="_self">Notion</a>
3. 랜덤 맵 타워 디펜스 게임 (2023.05 ~ 2023.06)
설명: 게임의 반복 플레이 가치를 높이기 위해 매 판마다 지도와 적의 생성 위치가 무작위로 변경되는 타워 디펜스 게임.
나의 역할 및 기여: 깊이 우선 탐색(DFS) 알고리즘을 변형하여 랜덤하게 노드를 방문하는 방식으로 맵 생성 로직 구현.
다익스트라(Dijkstra) 알고리즘을 활용하여 생성된 맵에서 적의 최적 이동 경로를 계산하는 로직 구현. 사용 기술: Android Studio(Java), DFS Algorithm, Dijkstra's Algorithm
<br>Link: <a data-tooltip-position="top" aria-label="https://github.com/SuperNoobChallenge/Random_Map_Tower_Defense" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/SuperNoobChallenge/Random_Map_Tower_Defense" target="_self">GitHub Repository</a>, <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=5YuW43d8cos&amp;t=280s" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=5YuW43d8cos&amp;t=280s" target="_self">YouTube Demo</a>, <a data-tooltip-position="top" aria-label="https://shrub-ninja-35e.notion.site/1f0ea2da1122819c9272e6873ba276ae" rel="noopener nofollow" class="external-link is-unresolved" href="https://shrub-ninja-35e.notion.site/1f0ea2da1122819c9272e6873ba276ae" target="_self">Notion</a> 컴퓨터공학과 학부 연구생 (목원대학교) 기간: 2022.04 ~ 2024.06 (약 2년 2개월)
주요 활동: 인공지능 모델 학습 및 데이터 분석
연구 보고서 작성 대전-세종-충남(DSC) CNU SW아카데미 기간: 2024.07 ~ 2024.12 (약 5개월)
과정: 웹프론트엔드 과정
주요 활동: 총 680시간 교육 과정 이수 목원대학교 컴퓨터공학과 (학사) 졸업: 2025년 02월
학점: 4.35 / 4.5 정보처리기사: 2024.06.18 취득
PCCP Python3 Lv.3: 2024.11.23 취득 우수상 - 2024학년도 전기 학위수여식 (수여자: 목원대학교 총장, 2025.02.20)
장려상 - 2024 캡스톤디자인 창업 Boot-Up 메이커톤 (수여자: 목원대학교 총장, 2024.12.06)
]]></description><link>김영현-신입-개발자-포트폴리오.html</link><guid isPermaLink="false">김영현  신입 개발자 포트폴리오.md</guid><pubDate>Wed, 24 Sep 2025 09:13:09 GMT</pubDate></item><item><title><![CDATA[Drawing 2025-12-19 21.13.58]]></title><description><![CDATA[⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: 'Decompress current Excalidraw file'. For more info check in plugin settings under 'Saving'0dd .. 1 dd dd d ]]></description><link>프로젝트/drawing-2025-12-19-21.13.58.excalidraw.html</link><guid isPermaLink="false">프로젝트/Drawing 2025-12-19 21.13.58.excalidraw.md</guid><pubDate>Fri, 19 Dec 2025 12:17:35 GMT</pubDate></item><item><title><![CDATA[무제]]></title><description><![CDATA[dd]]></description><link>프로젝트/무제.html</link><guid isPermaLink="false">프로젝트/무제.md</guid><pubDate>Fri, 19 Dec 2025 12:13:09 GMT</pubDate></item><item><title><![CDATA[애노테이션 기반 검증]]></title><description><![CDATA[-애노테이션 사용-
대부분의 검증 기능은 빈 값, 크기와 같은 단순한 검증을 수행한다.
이러한 단순한 기능을 매번 작성하는 것은 상당히 번거롭다.
그래서 스프링이 제공하는 애노테이션으로 퉁침글로벌 Validator를 직접 등록하면 스프링 부트는 Bean Validator를 글로벌 Validator 로 등록하지 않는다
글로벌 검증기가 있으면 애노테이션 기반 검증기가 동작하지 않는다.검증 애노테이션 모음
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/#validator-defineconstraints-spec" target="_self">https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/#validator-defineconstraints-spec</a>build.gradle에 해당 종속성 추가(스프링 전용 애노테이션을 사용하기 위한)implementation 'org.springframework.boot:spring-boot-starter-validation'@Validated : 스프링 전용 검증 애노테이션
@Valid : 자바 표준 검증 애노테이션@Validated 는 groups 이라는 기능을 포함하고 있다.
<br><a class="internal-link" data-href="스프링/검증/검증 구현(Bean)/V2.md" href="스프링/검증/검증-구현(bean)/v2.html" target="_self" rel="noopener nofollow">groups</a>이라는 기능은 후술
]]></description><link>스프링/검증/검증-구현(bean)/애노테이션-기반-검증.html</link><guid isPermaLink="false">스프링/검증/검증 구현(Bean)/애노테이션 기반 검증.md</guid><pubDate>Tue, 23 Sep 2025 09:59:19 GMT</pubDate></item><item><title><![CDATA[V2]]></title><description><![CDATA[-검증 조건이 다른 경우-
groups 기능을 사용
<a class="internal-link" data-href="스프링/검증/검증 구현(Bean)/V3.md" href="스프링/검증/검증-구현(bean)/v3.html" target="_self" rel="noopener nofollow">DTO를 사용하는 방법</a>이 더 좋다
모델이 너무 많은 기능을 수행하기 때문에 유지보수가 어려움(만약에 검증 조건이 100가지라면?)
데이터베이스에 저장되는 객체를 외부에 노출하지 말자. 꼭 필요한 데이터만 넘길 것
그룹을 지정할 인터페이스를 생성한다(다른 파일에!)public interface SaveCheck { }public interface UpdateCheck { }모델의 검증 애노테이션에 그룹을 추가@Data public class Item { @NotNull(groups = UpdateCheck.class) private Long id; @NotBlank(groups = {SaveCheck.class, UpdateCheck.class}) private String itemName; @NotNull(groups = {SaveCheck.class, UpdateCheck.class}) @Range(min = 1000, max = 1000000) private Integer price; @NotNull(groups = {SaveCheck.class, UpdateCheck.class}) @Max(value = 9999, groups = {SaveCheck.class}) private Integer quantity;컨트롤러 코드의 @Validated에 그룹을 지정public String addItem2(@Validated(SaveCheck.class) @ModelAttribute Item item, ...public String editV2(@PathVariable Long itemId, @Validated(value = UpdateCheck.class) @ModelAttribute Item item, ...]]></description><link>스프링/검증/검증-구현(bean)/v2.html</link><guid isPermaLink="false">스프링/검증/검증 구현(Bean)/V2.md</guid><pubDate>Tue, 23 Sep 2025 09:59:18 GMT</pubDate></item><item><title><![CDATA[왜 스프링인가]]></title><description><![CDATA[스프링은 <a class="internal-link" data-href="객체 지향 프로그래밍이란.md" href="스프링/객체-지향-프로그래밍이란.html" target="_self" rel="noopener nofollow">객체 지향 프로그래밍</a>을 위해 탄생한 <a class="internal-link" data-href="프레임워크 vs 라이브러리.md" href="스프링/프레임워크-vs-라이브러리.html" target="_self" rel="noopener nofollow">프레임워크</a>로
좋은 객체 기반 애플리케이션을 개발하는데 특화되어 있다.<br>스프링은 의존관계 주입 (Dependency injection,DI) 컨테이너를 제공해 <a class="internal-link" data-href="SOLID 좋은 객체 지향 설계를 위한 5 원칙.md" href="스프링/solid-좋은-객체-지향-설계를-위한-5-원칙.html" target="_self" rel="noopener nofollow">OCP, DIP</a>를 가능하게 지원한다.
이를 통해 클라이언트 코드의 변경 없이 확장할 수 있다.]]></description><link>스프링/왜-스프링인가.html</link><guid isPermaLink="false">스프링/왜 스프링인가.md</guid><pubDate>Tue, 23 Sep 2025 09:59:18 GMT</pubDate></item><item><title><![CDATA[SOLID 좋은 객체 지향 설계를 위한 5 원칙]]></title><description><![CDATA[ 단일 책임 원칙 (Single Responsibility Principle, SRP)
한 클래스는 하나의 책임만 가져야 한다
하나의 책임이라는 모호한 말은 문맥과 상황에 따라 다르게 적용된다
중요한 것은 변경이 있을 때 파급이 적어야 한다는 것이다
예를 들어 할인 정책 등을 변경했는데 SQL 코드가 변해야 한다면 원칙을 지키지 못하였다고 할 수 있다. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다
다형성을 이용하면 수정을 하지 않고 확장을 해야 한다는 이상한 법칙을 지킬 수 있다.
즉 인터페이스를 구현한 새 클래스를 만들어서 새로운 기능을 구현
하지만 이 방법을 적용하면 OCP를 지키지 못하는 경우가 생긴다
OCP를 지키기 위해 객체를 설정하고 관계를 맺어주는 별도의 <a class="internal-link" data-href="조립, 설정자란 무엇인가.md" href="스프링/조립,-설정자란-무엇인가.html" target="_self" rel="noopener nofollow">조립, 설정자</a>가 필요하다 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
기능적으로 규약을 보장해야 한다는 의미로
예를 들어 자동차 인터페이스의 엑셀은 동력을 제동하는 기능으로 타 기능으로 구현(와이퍼 작동)하면 안 된다는 의미이다. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스보다 낫다
예를 들어 자동차 인터페이스를 운전, 정비, 속도계 등등의 인터페이스들로 분리하면 정비 인터페이스가 변해도 타 인터페이스에 영향이 가지 않는다
인터페이스를 분리하며 명확해지고 대체 가능성이 높아짐 의존관계 역전 원칙 (Dependency Inversion Principle, DIP)
프로그래머는 추상화에 의존해야지 구체화에 의존해선 안 된다
클라이언트 코드가 구현 클래스를 알고 있으면 이 원칙을 준수하지 않은 것
아래 사진은 클라이언트 코드가 추상화에도 의존하고 있고 구체화에도 의존하고 있다<br>
<img alt="제목 없는 다이어그램.drawio.png" src="archive/media/제목-없는-다이어그램.drawio.png" target="_self" style="width: 600px; max-width: 100%;"> ]]></description><link>스프링/solid-좋은-객체-지향-설계를-위한-5-원칙.html</link><guid isPermaLink="false">스프링/SOLID 좋은 객체 지향 설계를 위한 5 원칙.md</guid><pubDate>Tue, 23 Sep 2025 09:59:18 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[객체 지향 프로그래밍이란]]></title><description><![CDATA[컴퓨터 부품을 갈아 끼우듯이(ex. ssd or hhd)
프로그래밍을 할 때 컴포넌트를(여러 기능) 쉽고 유연하게 변경할 수 있도록 개발하는 방식<img alt="제목 없는 다이어그램.drawio 2.png" src="archive/media/제목-없는-다이어그램.drawio-2.png" target="_self" style="width: 650px; max-width: 100%;">역할(인터페이스)과 구현(클래스)로 기능을 분리해 구현클라이언트(다른 기능)는 인터페이스를 통해 어떤 기능을 받나 알 수 있으나 어떻게 받는지는 알 필요가 없음
예를 들어 사용자 데이터를 받을 때 데이터베이스에서 받는가 임시로 직접 입력받은 데이터인지 알 필!요가 없다.기능은 자기 자신의 기능만 책임지면 되고, 클라이언트에 영향을 주지 않고 추가적인 수정을 할 수 있음가장 중요하게 생각하여야 할 것은 인터페이스의 변화가 없게 설계를 해야 한다
인터페이스가 변하면 그 하위 모든 기능을 뒤집어엎어야 하기 때문이다.<br>좋은 객체 지향 설계를 위한 원칙이 <a class="internal-link" data-href="SOLID 좋은 객체 지향 설계를 위한 5 원칙.md" href="스프링/solid-좋은-객체-지향-설계를-위한-5-원칙.html" target="_self" rel="noopener nofollow">SOLID</a>다객체 지향의 핵심은 다형성이나 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발을 할 수 없다.
왜냐하면 구현 객체를 변경할 때 클라이언트 코드도 변경되기 때문이다
즉 OCP, DIP를 지킬 수 없다.<br>
<a class="internal-link" data-href="조립, 설정자란 무엇인가.md" href="스프링/조립,-설정자란-무엇인가.html" target="_self" rel="noopener nofollow">무언가 더 필요하다.</a>]]></description><link>스프링/객체-지향-프로그래밍이란.html</link><guid isPermaLink="false">스프링/객체 지향 프로그래밍이란.md</guid><pubDate>Tue, 23 Sep 2025 09:59:18 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[세션의 생명 주기]]></title><description><![CDATA[세션은 무한정 유지해서는 안 된다.
보안과 리소스 관리를 위해 주기적으로 제거해야 한다.생성
사용자가 사이트에 접속하여 세션 ID 를 발급할 때 생성
유지
사용자가 사이트 내에서 계속 활동하면 (HTTP 메시지 전송), 설정된 만료 시간이 계속 갱신
소멸
브라우저 종료 브라우저를 닫으면 세션 ID 쿠키가 사라져 연결 종료(서버에서 설정) 타임아웃 일정 시간 동안 요청을 보내지 않으면 서버가 세션을 삭제 명시적 로그아웃 로그아웃 버튼 등을 눌러 서버로 세션 삭제 요청을 보냄 ]]></description><link>스프링/세션/세션의-생명-주기.html</link><guid isPermaLink="false">스프링/세션/세션의 생명 주기.md</guid><pubDate>Mon, 22 Sep 2025 06:39:09 GMT</pubDate></item><item><title><![CDATA[세션이란]]></title><description><![CDATA[비연속적인 HTTP 환경에서 연속적인 서비스를 제공하기 위한 기법
주로 쿠키를 기반으로 동작한다.로그인 상태 유지 등의 기능을 제공한다.]]></description><link>스프링/세션/세션이란.html</link><guid isPermaLink="false">스프링/세션/세션이란.md</guid><pubDate>Mon, 22 Sep 2025 05:38:20 GMT</pubDate></item><item><title><![CDATA[무제]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://kkongchii.tistory.com/entry/Spring-Boot-%EC%A0%95%EC%A0%81-%ED%8C%8C%EC%9D%BC-%EB%A1%9C%EB%93%9C-%EC%8B%9C-URL%EC%97%90-Jsessionid-%EB%B6%99%EB%8A%94-%EA%B2%BD%EC%9A%B0-%ED%95%B4%EA%B2%B0" target="_self">https://kkongchii.tistory.com/entry/Spring-Boot-%EC%A0%95%EC%A0%81-%ED%8C%8C%EC%9D%BC-%EB%A1%9C%EB%93%9C-%EC%8B%9C-URL%EC%97%90-Jsessionid-%EB%B6%99%EB%8A%94-%EA%B2%BD%EC%9A%B0-%ED%95%B4%EA%B2%B0</a>]]></description><link>스프링/세션/무제.html</link><guid isPermaLink="false">스프링/세션/무제.md</guid><pubDate>Sat, 20 Sep 2025 07:45:53 GMT</pubDate></item><item><title><![CDATA[V4(API)]]></title><description><![CDATA[API는 @ModelAttribute 가 아닌 @RequestBody를 사용하는데 약간의 문제가 있다.public Object addItem(@RequestBody @Validated ItemSaveForm form, BindingResult bindingResult){ log.info("API 컨트롤러 호출");데이터를 잘못 넣으면 에러가 발생해 모든 필드에서 검증이 되지 않는다.in{ "itemName":"hello", "price":"qqq", "quantity":1000}out{ "timestamp": "2025-09-19T09:08:19.542+00:00", "status": 400, "error": "Bad Request", "path": "/validation/api/items/add"}]]></description><link>스프링/검증/검증-구현(bean)/v4(api).html</link><guid isPermaLink="false">스프링/검증/검증 구현(Bean)/V4(API).md</guid><pubDate>Fri, 19 Sep 2025 09:17:44 GMT</pubDate></item><item><title><![CDATA[V3]]></title><description><![CDATA[-DTO 사용-
외부로 나가는 데이터는 DTO를 사용해 꼭 필요한 정보만 줘야 한다.
관심사 분리 : 만약 API 스팩 같은 요구 데이터가 변하였으면? 데이터베이스랑 엮여 있는 객체를 수정할 수는 없다. 나중에 가서 수정하는 것 보다. 미리미리 구분하는 것이 정신 건강에 좋다.
데이터 노출 관리 : 실수로 중요 데이터를 전송하면 위험하다. 그룹 회원 이름만 보내면 되는데 집 주소, 전화번호 등을 같이 보내는 것은 옳지 않다.
DTO 생성(다른 파일로)@Data public class ItemSaveForm { @NotBlank private String itemName; @NotNull @Range(min = 1000,max = 1000000) private Integer price; @NotNull @Max(9999) private Integer quantity; }@Data public class ItemUpdateForm { @NotNull private Long id; @NotBlank private String itemName; @NotNull @Range(min = 1000,max = 1000000) private Integer price; private Integer quantity; }@ModelAttribute의 객체를 다르게 한다. 이 경우 view 에 들어가는 이름이 달라진다
필요시 따로 명칭을 지정한다.
프로젝트가 커지면 객체 변환 과정을 자동화해주는 도구도 고려해야 한다.(MapStruct, ModelMapper)public String addItem(@Validated @ModelAttribute("item") ItemSaveForm form, BindingResult bindingResult, ...){	...	Item item = new Item(); item.setItemName(form.getItemName()); item.setPrice(form.getPrice()); item.setQuantity(form.getQuantity());	...}public String edit(@PathVariable Long itemId, @Validated @ModelAttribute("item") ItemUpdateForm form, BindingResult bindingResult){	...	Item itemParam = new Item(); itemParam.setItemName(form.getItemName()); itemParam.setPrice(form.getPrice()); itemParam.setQuantity(form.getQuantity());	...}]]></description><link>스프링/검증/검증-구현(bean)/v3.html</link><guid isPermaLink="false">스프링/검증/검증 구현(Bean)/V3.md</guid><pubDate>Fri, 19 Sep 2025 09:02:49 GMT</pubDate></item><item><title><![CDATA[V2]]></title><description><![CDATA[-BindingResult 사용-bindingResult는 model.addAttribute로 값을 따로 넘겨줄 필요가 없다.
bindingResult의 파라미터는 검증하는 대상의 파라미터 뒤에 위치해야 한다.public String addItemV1(@ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes, Model model) { // 검증 로직 if(!StringUtils.hasText(item.getItemName())){ bindingResult.addError(new FieldError("item","itemName","이름 필수.")); } if (bindingResult.hasErrors()){ return "validation/v2/addForm"; }	return "redirect:/validation/v2/items/{itemId}";}FieldError 생성자 파라미터에 의한 차이
3번째 파라미터에 view 에서 넘어오는 값을 지정해 주면 에러가 발생해 해당 화면으로 돌아가도 입력 값이 유지되도록 할 수 있다.
bindingResult.addError(new FieldError("item","itemName","이름 필수.")); // vsbindingResult.addError(new FieldError("item","itemName", item.getItemName(), false, null, null,"이름 필수."));thymeleaf 코드에서 값 확인 방법
글로벌 오류 : #fields.globalErrors()
필드 오류 : th:errors="*{itemName}"
&lt;div th:if="${#fields.hasGlobalErrors()}"&gt; &lt;p class="field-error" th:each="err : ${#fields.globalErrors()}" th:text="${err}"&gt;글로벌 오류 메시지&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="itemName" th:text="#{label.item.itemName}"&gt;상품명&lt;/label&gt; &lt;input type="text" id="itemName" th:field="*{itemName}" th:errorclass="field-error" class="form-control" placeholder="이름을 입력하세요"&gt; &lt;div class="field-error" th:errors="*{itemName}"&gt; 상품명 오류 &lt;/div&gt; &lt;/div&gt;]]></description><link>스프링/검증/검증-구현(일반)/v2.html</link><guid isPermaLink="false">스프링/검증/검증 구현(일반)/V2.md</guid><pubDate>Fri, 19 Sep 2025 08:40:20 GMT</pubDate></item><item><title><![CDATA[V1]]></title><description><![CDATA[모델에 검증 애노테이션 추가@Data public class Item { @NotNull private Long id; @NotBlank private String itemName; @NotNull @Range(min = 1000, max = 1000000) private Integer price; @NotNull @Max(value = 9999) private Integer quantity;검증을 원하는 파라미터에 @Validated 추가public String addItem(@Validated @ModelAttribute Item item, BindingResult bindingResult, ...) {]]></description><link>스프링/검증/검증-구현(bean)/v1.html</link><guid isPermaLink="false">스프링/검증/검증 구현(Bean)/V1.md</guid><pubDate>Fri, 19 Sep 2025 08:27:31 GMT</pubDate></item><item><title><![CDATA[오브젝트 오류(글로벌)]]></title><description><![CDATA[특정 필드가 아닌 오브젝트 관련 오류를 처리하는 방법은 @ScriptAssert() 을 사용하면 되기는 한다. @Data@ScriptAssert(lang = "javascript", script = "_this.price * _this.quantity &gt;= 10000")public class Item { ... }그런데 너무 제약이 많고 복잡하다. 특히 현시점에서 이 방식을 사용하려면 지금은 사용하지 않는 nashorn-core를 추가해야 한다.
사용하기 편한 거도 아니고, 수식에 문제가 있어도 바로 알 수 없으므로 이 방식을 사용하는 것은 추천되지 않는다.implementation 'org.openjdk.nashorn:nashorn-core:15.3그렇기 때문에 오브젝트 오류 부분은 자바 코드로 작성하자if (item.getPrice() != null &amp;&amp; item.getQuantity() != null) { int resultPrice = item.getPrice() * item.getQuantity();	if (resultPrice &lt; 10000) { bindingResult.reject("totalPriceMin", new Object[]{10000, resultPrice}, null);	}}]]></description><link>스프링/검증/검증-구현(bean)/오브젝트-오류(글로벌).html</link><guid isPermaLink="false">스프링/검증/검증 구현(Bean)/오브젝트 오류(글로벌).md</guid><pubDate>Fri, 19 Sep 2025 07:51:41 GMT</pubDate></item><item><title><![CDATA[Bean Validation의 에러 코드(메시지)]]></title><description><![CDATA[에러 코드 메시지 생성 방식은 스프링의 메시지 생성 방식과 유사하다
NotBlank : 오류 코드(애노테이션과 같음)
item : BindingResult 검증 하는 대상명(view로 넘어가는 이름)
itemName : 검증하는 변수명@NotBlank
NotBlank.item.itemName
NotBlank.itemName
NotBlank.java.lang.String
NotBlank
@Range
Range.item.price
Range.price
Range.java.lang.Integer
Range
메시지 등록NotBlank={0} 공백X Range={0}, {2} ~ {1} 허용 Max={0}, 최대 {1}{0}은 필드명, {n}은 각각의 애노테이션마다 다름]]></description><link>스프링/검증/검증-구현(bean)/bean-validation의-에러-코드(메시지).html</link><guid isPermaLink="false">스프링/검증/검증 구현(Bean)/Bean Validation의 에러 코드(메시지).md</guid><pubDate>Fri, 19 Sep 2025 07:38:09 GMT</pubDate></item><item><title><![CDATA[바인딩에 실패한 경우(타입 오류)]]></title><description><![CDATA[BeanValidator는 바인딩에 실패한 필드는 BeanValidation을 적용하지 않음
당연한 현상인 것이 타입 변환에 성공해야지 필드에 값을 할당할 수 있기 때문
(일단 모델 객체에 바인딩 받는 값이 정상으로 들어와야 검증도 의미가 있다.)
@ModelAttribute 데이터 획득
각각의 필드 타입 변환시도
변환에 성공한 필드만 BeanValidation 적용 타입 변환 시도 실패 시 typeMismatch FieldError 추가 해당 필드는 검증X 사용자가 같은 항목을 여러 번 수정하는 것을 최소화하기 때문에 클라이언트 사이드 검증이 중요]]></description><link>스프링/검증/검증-구현(bean)/바인딩에-실패한-경우(타입-오류).html</link><guid isPermaLink="false">스프링/검증/검증 구현(Bean)/바인딩에 실패한 경우(타입 오류).md</guid><pubDate>Fri, 19 Sep 2025 07:26:24 GMT</pubDate></item><item><title><![CDATA[검증이란]]></title><description><![CDATA[사용자의 입력을 서버에서 처리, 저장하기 전 값이 정상적인 범주인지 확인하고 조치하는 과정왜 검증을 해야 할까?
사용자가 입력값을 잘못 주었을 때 에러 페이지가 나타난다면 나라도 안 씀 ㅋㅋ
사용자가 입력값을 잘못 주었을 때 저장되지 않은 값들이 다 날아가면 나라도 안 씀 특별한 기준이 있는 경우 ex.) 글자 수 제한, 가격 범위, 값 잘못 입력 등등 왜 서버 사이트에서 검증을 해야 할까?
클라이언트의 코드는 언제라도 조작될 수 있기 때문
XSS 또는 SQL 주입 등의 공격을 막기 위해서는 서버 단에서 입력 값을 반드시 검증해야 함
주의할 점
서버만으로 검증하면 즉각적인 고객 사용성이 부족해짐
API 방식을 사용한다면 API 스펙을 잘 정의해서 응답 결과에 남겨주어야 함
]]></description><link>스프링/검증/검증이란.html</link><guid isPermaLink="false">스프링/검증/검증이란.md</guid><pubDate>Wed, 17 Sep 2025 09:14:47 GMT</pubDate></item><item><title><![CDATA[메시지 키값 생성, 선택 방식]]></title><description><![CDATA[BindingResult은 오류 메시지 키 값을 생성하는 기능 또한 수행한다그럼 어떤 방식으로 생성되는가?
오브젝트명 : @ModelAttribute Item item에서 item
bindingResult.rejectValue("itemName", "required"); 오류코드 : required
필드명 : itemName 위 3가지 값을 이용해 오류 코드를 만들어낸다.
public String addItemV5(@ModelAttribute Item item, BindingResult bindingResult,만들어내는 키 값과 선택 우선순위는 다음과 같다
1순위 (구체적)
오류코드.오브젝트명.필드명
ex) required.item.itemName
2순위
오류코드.필드명
ex) required.itemName
3순위
오류코드.필드타입
ex) required.java.lang.
4순위 (범용적)
오류코드
ex) required
이거 4개 만드는 것은 확정임!!
어떤 오류는 구체적으로, 어떤 거는 범용적으로 정하는 것은 오류코드 properties에서 결정
properties에 자세한 것을 적으면 자세하게 나오고 범용적인 거만 적으면 범용적으로 나옴
이 오류코드 properties만 수정하면 클라이언트의 글자 바꾸기 떼쓰기를 수월하게 조치할 수 있음
Thymeleaf가 메시지를 찾는 방법
타임리프는 렌더링을 시작할 때 스프링으로부터 Model 객체를 전달받고, 이 객체에 Result 객체가 있음
th:errors의 값*{itemName} == #{item.itemName}이니 오브젝트 이름이 item이고 필드이름이 itemName인 메시지 키 값을 찾음 왜 오류코드는 없어도 되는가? 애초에 해당 오류가 없으면 Result에 없을 것이기 때문
th:errors를 사용하는 이유는 단순히 에러 메시지를 어디에 출력할지 위치를 지정한 것이다. Result로부터 FieldError 객체들의 리스트를 전달받고 리스트가 비어있지 않으면
FieldError를 MessageSource에 전달하여 메시지 해석 요청
&lt;div&gt; &lt;label for="itemName" th:text="#{label.item.itemName}"&gt;상품명&lt;/label&gt; &lt;input type="text" id="itemName" th:field="*{itemName}" th:errorclass="field-error" class="form-control" placeholder="이름을 입력하세요"&gt; &lt;div class="field-error" th:errors="*{itemName}"&gt; 상품명 오류 &lt;/div&gt; &lt;/div&gt;]]></description><link>스프링/검증/메시지-키값-생성,-선택-방식.html</link><guid isPermaLink="false">스프링/검증/메시지 키값 생성, 선택 방식.md</guid><pubDate>Wed, 17 Sep 2025 09:13:11 GMT</pubDate></item><item><title><![CDATA[V6]]></title><description><![CDATA[-리팩토링 : 관심사의 분리 + @-가장 맨 앞에 @Validated 넣으면 스프링이 자동으로 검수 수행1private final ItemValidator itemValidator;23// 컨트롤러 호출 될 때 마다 먼저 호출되면서 검증기를 넣어 둠 4@InitBinder 5public void init(WebDataBinder dataBinder){ 6 dataBinder.addValidators(itemValidator); 7}89public String addItemV6(@Validated @ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes, Model model) { 10 11 if (bindingResult.hasErrors()){ 12 return "validation/v2/addForm"; 13 }14 ...]]></description><link>스프링/검증/검증-구현(일반)/v6.html</link><guid isPermaLink="false">스프링/검증/검증 구현(일반)/V6.md</guid><pubDate>Wed, 17 Sep 2025 07:24:10 GMT</pubDate></item><item><title><![CDATA[V5]]></title><description><![CDATA[-리팩토링 : 관심사의 분리-컨트롤러 코드가 에러 검증까지 하기에는 너무 많은 역할을 수행하기 때문에 따로 클래스를 파서 관심사를 분리
Validator 인터페이스의 supports, validate 메소드를 구현하면 된다. supports : 오브젝트가 처리 할 수 있는지 검증
validate : 실제 검증 코드 @Component public class ItemValidator implements Validator { @Override public boolean supports(Class&lt;?&gt; clazz) { return Item.class.isAssignableFrom(clazz); // 클래스나 인터페이스 상속했는지 체크 // Item 이 슈퍼클래스인가? 를 뭍는거임 } @Override public void validate(Object target, Errors errors) { Item item = (Item) target; // 검증 로직 if(!StringUtils.hasText(item.getItemName())) { errors.rejectValue("itemName", "required"); //??? 아 } } }컨트롤러에서는 해당 검증기를 생성 후 @InitBinder를 사용해 매 컨트롤러 호출 전 검증기를 먼저 호출1private final ItemValidator itemValidator;23// 컨트롤러 호출 될 때 마다 먼저 호출되면서 검증기를 넣어 둠 4@InitBinder 5public void init(WebDataBinder dataBinder){ 6 dataBinder.addValidators(itemValidator); 7}89public String addItemV5(@ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes, Model model) { 10 11 if(itemValidator.supports(item.getClass())){ 12 itemValidator.validate(item, bindingResult); 13 }14 ...]]></description><link>스프링/검증/검증-구현(일반)/v5.html</link><guid isPermaLink="false">스프링/검증/검증 구현(일반)/V5.md</guid><pubDate>Wed, 17 Sep 2025 07:20:15 GMT</pubDate></item><item><title><![CDATA[V3]]></title><description><![CDATA[-메시지, 국제화 적용-FieldError 생성자 5번째 파라미터에(codes) 메시지 키 값을 넣으면 메시지를 지정할 수 있다if(!StringUtils.hasText(item.getItemName())){ bindingResult.addError(new FieldError("item","itemName", item.getItemName(), false, new String[]{"required.item.itemName"}, null,null)); }#==FieldError== #Level1 required.item.itemName=상품 이름은 필수입니다. range.item.price=가격은 {0} ~ {1} 까지 허용합니다. max.item.quantity=수량은 최대 {0} 까지 허용합니다.thymeleaf 코드 유지&lt;div th:if="${#fields.hasGlobalErrors()}"&gt; &lt;p class="field-error" th:each="err : ${#fields.globalErrors()}" th:text="${err}"&gt;글로벌 오류 메시지&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="itemName" th:text="#{label.item.itemName}"&gt;상품명&lt;/label&gt; &lt;input type="text" id="itemName" th:field="*{itemName}" th:errorclass="field-error" class="form-control" placeholder="이름을 입력하세요"&gt; &lt;div class="field-error" th:errors="*{itemName}"&gt; 상품명 오류 &lt;/div&gt; &lt;/div&gt;]]></description><link>스프링/검증/검증-구현(일반)/v3.html</link><guid isPermaLink="false">스프링/검증/검증 구현(일반)/V3.md</guid><pubDate>Wed, 17 Sep 2025 07:10:42 GMT</pubDate></item><item><title><![CDATA[V4]]></title><description><![CDATA[-메시지, 국제화 적용-짠 이전에 한 거 다 필요 없다 bindingResult.rejectValue 메소드를 사용해 대체 가능
필드 오류 지정 : rejectValue
글로벌 오류 지정 : reject
if(!StringUtils.hasText(item.getItemName())) { bindingResult.rejectValue("itemName", "required"); //??? 아 }if(item.getPrice() != null &amp;&amp; item.getQuantity() != null){ int resultPrice = item.getPrice() * item.getQuantity(); if (resultPrice &lt; 10000){ bindingResult.reject("totalPriceMin", new Object[]{10000, resultPrice}, null); } }그럼 어떤 방식으로 매칭되는가?
오브젝트명 : @ModelAttribute Item item에서 item
bindingResult.rejectValue("itemName", "required"); 오류코드 : required
필드명 : itemName 위 3가지 값을 이용해 오류 코드를 만들어내고, 이 코드로 메시지 값을 얻어낸다.
public String addItemV5(@ModelAttribute Item item, BindingResult bindingResult,thymeleaf 코드 유지&lt;div&gt; &lt;label for="itemName" th:text="#{label.item.itemName}"&gt;상품명&lt;/label&gt; &lt;input type="text" id="itemName" th:field="*{itemName}" th:errorclass="field-error" class="form-control" placeholder="이름을 입력하세요"&gt; &lt;div class="field-error" th:errors="*{itemName}"&gt; 상품명 오류 &lt;/div&gt; &lt;/div&gt;]]></description><link>스프링/검증/검증-구현(일반)/v4.html</link><guid isPermaLink="false">스프링/검증/검증 구현(일반)/V4.md</guid><pubDate>Wed, 17 Sep 2025 07:07:28 GMT</pubDate></item><item><title><![CDATA[V1]]></title><description><![CDATA[-그냥 깡구현-
<img alt="Pasted image 20250917134000.png" src="archive/media/pasted-image-20250917134000.png" target="_self" style="width: 425px; max-width: 100%;">Map을 사용해 오류를 저장 후 view에 넘긴다.Map&lt;String, String&gt; errors = new HashMap&lt;&gt;(); if(!StringUtils.hasText(item.getItemName())){ errors.put("itemName", "상품 이름은 필수입니다."); } if (!errors.isEmpty()){ model.addAttribute("errors", errors); return "validation/v1/addForm"; }return "redirect:/validation/v1/items/{itemId}";view에선 받은 값을 확인해 HTML 생성&lt;div th:if="${errors?.containsKey('globalError')}"&gt; &lt;p class="field-error" th:text="${errors['globalError']}"&gt;전체 오류 메시지&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="itemName" th:text="#{label.item.itemName}"&gt;상품명&lt;/label&gt; &lt;input type="text" id="itemName" th:field="*{itemName}" th:class="${errors?.containsKey('itemName')} ? 'form-control field-error' : 'form-control'" class="form-control" placeholder="이름을 입력하세요"&gt; &lt;div class="field-error" th:if="${errors?.containsKey('itemName')}" th:text="${errors['itemName']}"&gt; 상품명 오류 &lt;/div&gt; &lt;/div&gt;]]></description><link>스프링/검증/검증-구현(일반)/v1.html</link><guid isPermaLink="false">스프링/검증/검증 구현(일반)/V1.md</guid><pubDate>Wed, 17 Sep 2025 06:34:26 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[JPA 란 무엇인가]]></title><description><![CDATA[JPA(Java Persistence API)는 JAVA 애플리케이션과 JDBC 사이에서 동작하는 관리자로객체의 영속성을 관리해주는 역할을 수행한다.자바 ORM 표준 JPA 프로그래밍 - 기본편 섹선 2 보면서 추가 정리 요망]]></description><link>스프링/jpa-란-무엇인가.html</link><guid isPermaLink="false">스프링/JPA 란 무엇인가.md</guid><pubDate>Thu, 17 Jul 2025 09:21:33 GMT</pubDate></item><item><title><![CDATA[초기 설정 spring initializer 을 이용한]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://start.spring.io/" target="_self">https://start.spring.io/</a><br><img alt="Pasted image 20250707191531.png" src="archive/media/pasted-image-20250707191531.png" target="_self">]]></description><link>스프링/초기-설정-spring-initializer-을-이용한.html</link><guid isPermaLink="false">스프링/초기 설정 spring initializer 을 이용한.md</guid><pubDate>Mon, 07 Jul 2025 10:15:33 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[lombok (롬복)]]></title><description><![CDATA[여러 번 만들어야 하는 귀찮은 요소를 자동화해주는 프레임워크 종속성에 lombok을 추가
<img alt="Pasted image 20250707190523.png" src="archive/media/pasted-image-20250707190523.png" target="_self" style="width: 450px; max-width: 100%;">
플러그인에서 lombok을 설치<br>
<img alt="Pasted image 20250707190416.png" src="archive/media/pasted-image-20250707190416.png" target="_self" style="width: 400px; max-width: 100%;">
어노테이션 프로세서에서 어노테이션 처리 활성화<br>
<img alt="Pasted image 20250707190446.png" src="archive/media/pasted-image-20250707190446.png" target="_self" style="width: 400px; max-width: 100%;"> 클래스에 @Getter @Setter 을 붙여 설정<br>
<img alt="Pasted image 20250707190821.png" src="archive/media/pasted-image-20250707190821.png" target="_self" style="width: 350px; max-width: 100%;">
변수명 앞에 set or get 을 붙여 사용<br>
<img alt="Pasted image 20250707190915.png" src="archive/media/pasted-image-20250707190915.png" target="_self" style="width: 375px; max-width: 100%;"> ]]></description><link>스프링/lombok-(롬복).html</link><guid isPermaLink="false">스프링/lombok (롬복).md</guid><pubDate>Mon, 07 Jul 2025 10:09:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[IntelliJ 유용한 단축키(windows 기준)]]></title><description><![CDATA[CTRL + ALT + v : 입력값이 있을 때 변수 생성]]></description><link>스프링/intellij-유용한-단축키(windows-기준).html</link><guid isPermaLink="false">스프링/IntelliJ 유용한 단축키(windows 기준).md</guid><pubDate>Mon, 07 Jul 2025 09:40:34 GMT</pubDate></item><item><title><![CDATA[낙서장임]]></title><description><![CDATA[스프링의 핵심 개념
객체 기반 언어인 자바 기반 프레임워크
좋은 객체 기반 애플리케이션을 개발할 수 있게 지원좋은 객체 지향 프로그래밍이란?
코드를 갈아 끼우듯이
컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법으로
역할과 구현으로 세상을 구분클라이언트는 자동차의 내부 구조를 알 필요가 없음
대상의 내용을 주지 않고 추가 기능을 제공할 수 있다
예를 들어]]></description><link>스프링/낙서장임.html</link><guid isPermaLink="false">스프링/낙서장임.md</guid><pubDate>Mon, 07 Jul 2025 06:27:56 GMT</pubDate></item><item><title><![CDATA[프레임워크 vs 라이브러리]]></title><description><![CDATA[프레임워크는 내가 작성한 코드를 제어하고 대신 실행(ex. JUnit)
라이브러리는 내가 작성한 코드가 직접 제어의 흐름을 담당(ex. PyTorch)]]></description><link>스프링/프레임워크-vs-라이브러리.html</link><guid isPermaLink="false">스프링/프레임워크 vs 라이브러리.md</guid><pubDate>Mon, 07 Jul 2025 05:55:11 GMT</pubDate></item><item><title><![CDATA[조립, 설정자란 무엇인가]]></title><link>스프링/조립,-설정자란-무엇인가.html</link><guid isPermaLink="false">스프링/조립, 설정자란 무엇인가.md</guid><pubDate>Sat, 05 Jul 2025 06:53:53 GMT</pubDate></item></channel></rss>