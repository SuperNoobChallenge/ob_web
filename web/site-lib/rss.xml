<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[brain_obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>brain_obsidian</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 19 Sep 2025 10:15:15 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 19 Sep 2025 10:15:08 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[main]]></title><link>area/main.html</link><guid isPermaLink="false">Area/main.md</guid><pubDate>Fri, 19 Sep 2025 09:30:45 GMT</pubDate></item><item><title><![CDATA[V4(API)]]></title><description><![CDATA[API는 @ModelAttribute 가 아닌 @RequestBody를 사용하는데 약간의 문제가 있다.public Object addItem(@RequestBody @Validated ItemSaveForm form, BindingResult bindingResult){ log.info("API 컨트롤러 호출");데이터를 잘못 넣으면 에러가 발생해 모든 필드에서 검증이 되지 않는다.in{ "itemName":"hello", "price":"qqq", "quantity":1000}out{ "timestamp": "2025-09-19T09:08:19.542+00:00", "status": 400, "error": "Bad Request", "path": "/validation/api/items/add"}]]></description><link>area/스프링/검증/검증-구현(bean)/v4(api).html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(Bean)/V4(API).md</guid><pubDate>Fri, 19 Sep 2025 09:17:44 GMT</pubDate></item><item><title><![CDATA[V3]]></title><description><![CDATA[-DTO 사용-
외부로 나가는 데이터는 DTO를 사용해 꼭 필요한 정보만 줘야 한다.
관심사 분리 : 만약 API 스팩 같은 요구 데이터가 변하였으면? 데이터베이스랑 엮여 있는 객체를 수정할 수는 없다. 나중에 가서 수정하는 것 보다. 미리미리 구분하는 것이 정신 건강에 좋다.
데이터 노출 관리 : 실수로 중요 데이터를 전송하면 위험하다. 그룹 회원 이름만 보내면 되는데 집 주소, 전화번호 등을 같이 보내는 것은 옳지 않다.
DTO 생성(다른 파일로)@Data public class ItemSaveForm { @NotBlank private String itemName; @NotNull @Range(min = 1000,max = 1000000) private Integer price; @NotNull @Max(9999) private Integer quantity; }@Data public class ItemUpdateForm { @NotNull private Long id; @NotBlank private String itemName; @NotNull @Range(min = 1000,max = 1000000) private Integer price; private Integer quantity; }@ModelAttribute의 객체를 다르게 한다. 이 경우 view 에 들어가는 이름이 달라진다
필요시 따로 명칭을 지정한다.
프로젝트가 커지면 객체 변환 과정을 자동화해주는 도구도 고려해야 한다.(MapStruct, ModelMapper)public String addItem(@Validated @ModelAttribute("item") ItemSaveForm form, BindingResult bindingResult, ...){	...	Item item = new Item(); item.setItemName(form.getItemName()); item.setPrice(form.getPrice()); item.setQuantity(form.getQuantity());	...}public String edit(@PathVariable Long itemId, @Validated @ModelAttribute("item") ItemUpdateForm form, BindingResult bindingResult){	...	Item itemParam = new Item(); itemParam.setItemName(form.getItemName()); itemParam.setPrice(form.getPrice()); itemParam.setQuantity(form.getQuantity());	...}]]></description><link>area/스프링/검증/검증-구현(bean)/v3.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(Bean)/V3.md</guid><pubDate>Fri, 19 Sep 2025 09:02:49 GMT</pubDate></item><item><title><![CDATA[V2]]></title><description><![CDATA[-검증 조건이 다른 경우-
groups 기능을 사용
<a class="internal-link" data-href="./V3" href="area/스프링/검증/검증-구현(bean)/v3.html" target="_self" rel="noopener nofollow">DTO를 사용하는 방법</a>이 더 좋다
모델이 너무 많은 기능을 수행하기 때문에 유지보수가 어려움(만약에 검증 조건이 100가지라면?)
데이터베이스에 저장되는 객체를 외부에 노출하지 말자. 꼭 필요한 데이터만 넘길 것
그룹을 지정할 인터페이스를 생성한다(다른 파일에!)public interface SaveCheck { }public interface UpdateCheck { }모델의 검증 애노테이션에 그룹을 추가@Data public class Item { @NotNull(groups = UpdateCheck.class) private Long id; @NotBlank(groups = {SaveCheck.class, UpdateCheck.class}) private String itemName; @NotNull(groups = {SaveCheck.class, UpdateCheck.class}) @Range(min = 1000, max = 1000000) private Integer price; @NotNull(groups = {SaveCheck.class, UpdateCheck.class}) @Max(value = 9999, groups = {SaveCheck.class}) private Integer quantity;컨트롤러 코드의 @Validated에 그룹을 지정public String addItem2(@Validated(SaveCheck.class) @ModelAttribute Item item, ...public String editV2(@PathVariable Long itemId, @Validated(value = UpdateCheck.class) @ModelAttribute Item item, ...]]></description><link>area/스프링/검증/검증-구현(bean)/v2.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(Bean)/V2.md</guid><pubDate>Fri, 19 Sep 2025 08:42:01 GMT</pubDate></item><item><title><![CDATA[애노테이션 기반 검증]]></title><description><![CDATA[-애노테이션 사용-
대부분의 검증 기능은 빈 값, 크기와 같은 단순한 검증을 수행한다.
이러한 단순한 기능을 매번 작성하는 것은 상당히 번거롭다.
그래서 스프링이 제공하는 애노테이션으로 퉁침글로벌 Validator를 직접 등록하면 스프링 부트는 Bean Validator를 글로벌 Validator 로 등록하지 않는다
글로벌 검증기가 있으면 애노테이션 기반 검증기가 동작하지 않는다.검증 애노테이션 모음
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/#validator-defineconstraints-spec" target="_self">https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/#validator-defineconstraints-spec</a>build.gradle에 해당 종속성 추가(스프링 전용 애노테이션을 사용하기 위한)implementation 'org.springframework.boot:spring-boot-starter-validation'@Validated : 스프링 전용 검증 애노테이션
@Valid : 자바 표준 검증 애노테이션@Validated 는 groups 이라는 기능을 포함하고 있다.
<br><a class="internal-link" data-href="./V1" href="area/스프링/검증/검증-구현(bean)/v1.html" target="_self" rel="noopener nofollow">groups</a>이라는 기능은 후술
]]></description><link>area/스프링/검증/검증-구현(bean)/애노테이션-기반-검증.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(Bean)/애노테이션 기반 검증.md</guid><pubDate>Fri, 19 Sep 2025 08:40:44 GMT</pubDate></item><item><title><![CDATA[V2]]></title><description><![CDATA[-BindingResult 사용-bindingResult는 model.addAttribute로 값을 따로 넘겨줄 필요가 없다.
bindingResult의 파라미터는 검증하는 대상의 파라미터 뒤에 위치해야 한다.public String addItemV1(@ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes, Model model) { // 검증 로직 if(!StringUtils.hasText(item.getItemName())){ bindingResult.addError(new FieldError("item","itemName","이름 필수.")); } if (bindingResult.hasErrors()){ return "validation/v2/addForm"; }	return "redirect:/validation/v2/items/{itemId}";}FieldError 생성자 파라미터에 의한 차이
3번째 파라미터에 view 에서 넘어오는 값을 지정해 주면 에러가 발생해 해당 화면으로 돌아가도 입력 값이 유지되도록 할 수 있다.
bindingResult.addError(new FieldError("item","itemName","이름 필수.")); // vsbindingResult.addError(new FieldError("item","itemName", item.getItemName(), false, null, null,"이름 필수."));thymeleaf 코드에서 값 확인 방법
글로벌 오류 : #fields.globalErrors()
필드 오류 : th:errors="*{itemName}"
&lt;div th:if="${#fields.hasGlobalErrors()}"&gt; &lt;p class="field-error" th:each="err : ${#fields.globalErrors()}" th:text="${err}"&gt;글로벌 오류 메시지&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="itemName" th:text="#{label.item.itemName}"&gt;상품명&lt;/label&gt; &lt;input type="text" id="itemName" th:field="*{itemName}" th:errorclass="field-error" class="form-control" placeholder="이름을 입력하세요"&gt; &lt;div class="field-error" th:errors="*{itemName}"&gt; 상품명 오류 &lt;/div&gt; &lt;/div&gt;]]></description><link>area/스프링/검증/검증-구현(일반)/v2.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(일반)/V2.md</guid><pubDate>Fri, 19 Sep 2025 08:40:20 GMT</pubDate></item><item><title><![CDATA[V1]]></title><description><![CDATA[모델에 검증 애노테이션 추가@Data public class Item { @NotNull private Long id; @NotBlank private String itemName; @NotNull @Range(min = 1000, max = 1000000) private Integer price; @NotNull @Max(value = 9999) private Integer quantity;검증을 원하는 파라미터에 @Validated 추가public String addItem(@Validated @ModelAttribute Item item, BindingResult bindingResult, ...) {]]></description><link>area/스프링/검증/검증-구현(bean)/v1.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(Bean)/V1.md</guid><pubDate>Fri, 19 Sep 2025 08:27:31 GMT</pubDate></item><item><title><![CDATA[오브젝트 오류(글로벌)]]></title><description><![CDATA[특정 필드가 아닌 오브젝트 관련 오류를 처리하는 방법은 @ScriptAssert() 을 사용하면 되기는 한다. @Data@ScriptAssert(lang = "javascript", script = "_this.price * _this.quantity &gt;= 10000")public class Item { ... }그런데 너무 제약이 많고 복잡하다. 특히 현시점에서 이 방식을 사용하려면 지금은 사용하지 않는 nashorn-core를 추가해야 한다.
사용하기 편한 거도 아니고, 수식에 문제가 있어도 바로 알 수 없으므로 이 방식을 사용하는 것은 추천되지 않는다.implementation 'org.openjdk.nashorn:nashorn-core:15.3그렇기 때문에 오브젝트 오류 부분은 자바 코드로 작성하자if (item.getPrice() != null &amp;&amp; item.getQuantity() != null) { int resultPrice = item.getPrice() * item.getQuantity();	if (resultPrice &lt; 10000) { bindingResult.reject("totalPriceMin", new Object[]{10000, resultPrice}, null);	}}]]></description><link>area/스프링/검증/검증-구현(bean)/오브젝트-오류(글로벌).html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(Bean)/오브젝트 오류(글로벌).md</guid><pubDate>Fri, 19 Sep 2025 07:51:41 GMT</pubDate></item><item><title><![CDATA[Bean Validation의 에러 코드(메시지)]]></title><description><![CDATA[에러 코드 메시지 생성 방식은 스프링의 메시지 생성 방식과 유사하다
NotBlank : 오류 코드(애노테이션과 같음)
item : BindingResult 검증 하는 대상명(view로 넘어가는 이름)
itemName : 검증하는 변수명@NotBlank
NotBlank.item.itemName
NotBlank.itemName
NotBlank.java.lang.String
NotBlank
@Range
Range.item.price
Range.price
Range.java.lang.Integer
Range
메시지 등록NotBlank={0} 공백X Range={0}, {2} ~ {1} 허용 Max={0}, 최대 {1}{0}은 필드명, {n}은 각각의 애노테이션마다 다름]]></description><link>area/스프링/검증/검증-구현(bean)/bean-validation의-에러-코드(메시지).html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(Bean)/Bean Validation의 에러 코드(메시지).md</guid><pubDate>Fri, 19 Sep 2025 07:38:09 GMT</pubDate></item><item><title><![CDATA[바인딩에 실패한 경우(타입 오류)]]></title><description><![CDATA[BeanValidator는 바인딩에 실패한 필드는 BeanValidation을 적용하지 않음
당연한 현상인 것이 타입 변환에 성공해야지 필드에 값을 할당할 수 있기 때문
(일단 모델 객체에 바인딩 받는 값이 정상으로 들어와야 검증도 의미가 있다.)
@ModelAttribute 데이터 획득
각각의 필드 타입 변환시도
변환에 성공한 필드만 BeanValidation 적용 타입 변환 시도 실패 시 typeMismatch FieldError 추가 해당 필드는 검증X 사용자가 같은 항목을 여러 번 수정하는 것을 최소화하기 때문에 클라이언트 사이드 검증이 중요]]></description><link>area/스프링/검증/검증-구현(bean)/바인딩에-실패한-경우(타입-오류).html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(Bean)/바인딩에 실패한 경우(타입 오류).md</guid><pubDate>Fri, 19 Sep 2025 07:26:24 GMT</pubDate></item><item><title><![CDATA[def]]></title><link>area/스프링/검증/검증-구현(bean)/space/def.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(Bean)/space/def.json</guid><pubDate>Thu, 18 Sep 2025 08:57:46 GMT</pubDate></item><item><title><![CDATA[검증이란]]></title><description><![CDATA[사용자의 입력을 서버에서 처리, 저장하기 전 값이 정상적인 범주인지 확인하고 조치하는 과정왜 검증을 해야 할까?
사용자가 입력값을 잘못 주었을 때 에러 페이지가 나타난다면 나라도 안 씀 ㅋㅋ
사용자가 입력값을 잘못 주었을 때 저장되지 않은 값들이 다 날아가면 나라도 안 씀 특별한 기준이 있는 경우 ex.) 글자 수 제한, 가격 범위, 값 잘못 입력 등등 왜 서버 사이트에서 검증을 해야 할까?
클라이언트의 코드는 언제라도 조작될 수 있기 때문
XSS 또는 SQL 주입 등의 공격을 막기 위해서는 서버 단에서 입력 값을 반드시 검증해야 함
주의할 점
서버만으로 검증하면 즉각적인 고객 사용성이 부족해짐
API 방식을 사용한다면 API 스펙을 잘 정의해서 응답 결과에 남겨주어야 함
]]></description><link>area/스프링/검증/검증이란.html</link><guid isPermaLink="false">Area/스프링/검증/검증이란.md</guid><pubDate>Wed, 17 Sep 2025 09:14:47 GMT</pubDate></item><item><title><![CDATA[메시지 키값 생성, 선택 방식]]></title><description><![CDATA[BindingResult은 오류 메시지 키 값을 생성하는 기능 또한 수행한다그럼 어떤 방식으로 생성되는가?
오브젝트명 : @ModelAttribute Item item에서 item
bindingResult.rejectValue("itemName", "required"); 오류코드 : required
필드명 : itemName 위 3가지 값을 이용해 오류 코드를 만들어낸다.
public String addItemV5(@ModelAttribute Item item, BindingResult bindingResult,만들어내는 키 값과 선택 우선순위는 다음과 같다
1순위 (구체적)
오류코드.오브젝트명.필드명
ex) required.item.itemName
2순위
오류코드.필드명
ex) required.itemName
3순위
오류코드.필드타입
ex) required.java.lang.
4순위 (범용적)
오류코드
ex) required
이거 4개 만드는 것은 확정임!!
어떤 오류는 구체적으로, 어떤 거는 범용적으로 정하는 것은 오류코드 properties에서 결정
properties에 자세한 것을 적으면 자세하게 나오고 범용적인 거만 적으면 범용적으로 나옴
이 오류코드 properties만 수정하면 클라이언트의 글자 바꾸기 떼쓰기를 수월하게 조치할 수 있음
Thymeleaf가 메시지를 찾는 방법
타임리프는 렌더링을 시작할 때 스프링으로부터 Model 객체를 전달받고, 이 객체에 Result 객체가 있음
th:errors의 값*{itemName} == #{item.itemName}이니 오브젝트 이름이 item이고 필드이름이 itemName인 메시지 키 값을 찾음 왜 오류코드는 없어도 되는가? 애초에 해당 오류가 없으면 Result에 없을 것이기 때문
th:errors를 사용하는 이유는 단순히 에러 메시지를 어디에 출력할지 위치를 지정한 것이다. Result로부터 FieldError 객체들의 리스트를 전달받고 리스트가 비어있지 않으면
FieldError를 MessageSource에 전달하여 메시지 해석 요청
&lt;div&gt; &lt;label for="itemName" th:text="#{label.item.itemName}"&gt;상품명&lt;/label&gt; &lt;input type="text" id="itemName" th:field="*{itemName}" th:errorclass="field-error" class="form-control" placeholder="이름을 입력하세요"&gt; &lt;div class="field-error" th:errors="*{itemName}"&gt; 상품명 오류 &lt;/div&gt; &lt;/div&gt;]]></description><link>area/스프링/검증/메시지-키값-생성,-선택-방식.html</link><guid isPermaLink="false">Area/스프링/검증/메시지 키값 생성, 선택 방식.md</guid><pubDate>Wed, 17 Sep 2025 09:13:11 GMT</pubDate></item><item><title><![CDATA[V6]]></title><description><![CDATA[-리팩토링 : 관심사의 분리 + @-가장 맨 앞에 @Validated 넣으면 스프링이 자동으로 검수 수행1private final ItemValidator itemValidator;23// 컨트롤러 호출 될 때 마다 먼저 호출되면서 검증기를 넣어 둠 4@InitBinder 5public void init(WebDataBinder dataBinder){ 6 dataBinder.addValidators(itemValidator); 7}89public String addItemV6(@Validated @ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes, Model model) { 10 11 if (bindingResult.hasErrors()){ 12 return "validation/v2/addForm"; 13 }14 ...]]></description><link>area/스프링/검증/검증-구현(일반)/v6.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(일반)/V6.md</guid><pubDate>Wed, 17 Sep 2025 07:24:10 GMT</pubDate></item><item><title><![CDATA[V5]]></title><description><![CDATA[-리팩토링 : 관심사의 분리-컨트롤러 코드가 에러 검증까지 하기에는 너무 많은 역할을 수행하기 때문에 따로 클래스를 파서 관심사를 분리
Validator 인터페이스의 supports, validate 메소드를 구현하면 된다. supports : 오브젝트가 처리 할 수 있는지 검증
validate : 실제 검증 코드 @Component public class ItemValidator implements Validator { @Override public boolean supports(Class&lt;?&gt; clazz) { return Item.class.isAssignableFrom(clazz); // 클래스나 인터페이스 상속했는지 체크 // Item 이 슈퍼클래스인가? 를 뭍는거임 } @Override public void validate(Object target, Errors errors) { Item item = (Item) target; // 검증 로직 if(!StringUtils.hasText(item.getItemName())) { errors.rejectValue("itemName", "required"); //??? 아 } } }컨트롤러에서는 해당 검증기를 생성 후 @InitBinder를 사용해 매 컨트롤러 호출 전 검증기를 먼저 호출1private final ItemValidator itemValidator;23// 컨트롤러 호출 될 때 마다 먼저 호출되면서 검증기를 넣어 둠 4@InitBinder 5public void init(WebDataBinder dataBinder){ 6 dataBinder.addValidators(itemValidator); 7}89public String addItemV5(@ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes, Model model) { 10 11 if(itemValidator.supports(item.getClass())){ 12 itemValidator.validate(item, bindingResult); 13 }14 ...]]></description><link>area/스프링/검증/검증-구현(일반)/v5.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(일반)/V5.md</guid><pubDate>Wed, 17 Sep 2025 07:20:15 GMT</pubDate></item><item><title><![CDATA[V3]]></title><description><![CDATA[-메시지, 국제화 적용-FieldError 생성자 5번째 파라미터에(codes) 메시지 키 값을 넣으면 메시지를 지정할 수 있다if(!StringUtils.hasText(item.getItemName())){ bindingResult.addError(new FieldError("item","itemName", item.getItemName(), false, new String[]{"required.item.itemName"}, null,null)); }#==FieldError== #Level1 required.item.itemName=상품 이름은 필수입니다. range.item.price=가격은 {0} ~ {1} 까지 허용합니다. max.item.quantity=수량은 최대 {0} 까지 허용합니다.thymeleaf 코드 유지&lt;div th:if="${#fields.hasGlobalErrors()}"&gt; &lt;p class="field-error" th:each="err : ${#fields.globalErrors()}" th:text="${err}"&gt;글로벌 오류 메시지&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="itemName" th:text="#{label.item.itemName}"&gt;상품명&lt;/label&gt; &lt;input type="text" id="itemName" th:field="*{itemName}" th:errorclass="field-error" class="form-control" placeholder="이름을 입력하세요"&gt; &lt;div class="field-error" th:errors="*{itemName}"&gt; 상품명 오류 &lt;/div&gt; &lt;/div&gt;]]></description><link>area/스프링/검증/검증-구현(일반)/v3.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(일반)/V3.md</guid><pubDate>Wed, 17 Sep 2025 07:10:42 GMT</pubDate></item><item><title><![CDATA[V4]]></title><description><![CDATA[-메시지, 국제화 적용-짠 이전에 한 거 다 필요 없다 bindingResult.rejectValue 메소드를 사용해 대체 가능
필드 오류 지정 : rejectValue
글로벌 오류 지정 : reject
if(!StringUtils.hasText(item.getItemName())) { bindingResult.rejectValue("itemName", "required"); //??? 아 }if(item.getPrice() != null &amp;&amp; item.getQuantity() != null){ int resultPrice = item.getPrice() * item.getQuantity(); if (resultPrice &lt; 10000){ bindingResult.reject("totalPriceMin", new Object[]{10000, resultPrice}, null); } }그럼 어떤 방식으로 매칭되는가?
오브젝트명 : @ModelAttribute Item item에서 item
bindingResult.rejectValue("itemName", "required"); 오류코드 : required
필드명 : itemName 위 3가지 값을 이용해 오류 코드를 만들어내고, 이 코드로 메시지 값을 얻어낸다.
public String addItemV5(@ModelAttribute Item item, BindingResult bindingResult,thymeleaf 코드 유지&lt;div&gt; &lt;label for="itemName" th:text="#{label.item.itemName}"&gt;상품명&lt;/label&gt; &lt;input type="text" id="itemName" th:field="*{itemName}" th:errorclass="field-error" class="form-control" placeholder="이름을 입력하세요"&gt; &lt;div class="field-error" th:errors="*{itemName}"&gt; 상품명 오류 &lt;/div&gt; &lt;/div&gt;]]></description><link>area/스프링/검증/검증-구현(일반)/v4.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(일반)/V4.md</guid><pubDate>Wed, 17 Sep 2025 07:07:28 GMT</pubDate></item><item><title><![CDATA[V1]]></title><description><![CDATA[-그냥 깡구현-
<img alt="Pasted image 20250917134000.png" src="archive/media/pasted-image-20250917134000.png" target="_self" style="width: 425px; max-width: 100%;">Map을 사용해 오류를 저장 후 view에 넘긴다.Map&lt;String, String&gt; errors = new HashMap&lt;&gt;(); if(!StringUtils.hasText(item.getItemName())){ errors.put("itemName", "상품 이름은 필수입니다."); } if (!errors.isEmpty()){ model.addAttribute("errors", errors); return "validation/v1/addForm"; }return "redirect:/validation/v1/items/{itemId}";view에선 받은 값을 확인해 HTML 생성&lt;div th:if="${errors?.containsKey('globalError')}"&gt; &lt;p class="field-error" th:text="${errors['globalError']}"&gt;전체 오류 메시지&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="itemName" th:text="#{label.item.itemName}"&gt;상품명&lt;/label&gt; &lt;input type="text" id="itemName" th:field="*{itemName}" th:class="${errors?.containsKey('itemName')} ? 'form-control field-error' : 'form-control'" class="form-control" placeholder="이름을 입력하세요"&gt; &lt;div class="field-error" th:if="${errors?.containsKey('itemName')}" th:text="${errors['itemName']}"&gt; 상품명 오류 &lt;/div&gt; &lt;/div&gt;]]></description><link>area/스프링/검증/검증-구현(일반)/v1.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(일반)/V1.md</guid><pubDate>Wed, 17 Sep 2025 06:34:26 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[def]]></title><link>area/스프링/slf4j/space/def.html</link><guid isPermaLink="false">Area/스프링/SLF4J/space/def.json</guid><pubDate>Wed, 17 Sep 2025 05:06:52 GMT</pubDate></item><item><title><![CDATA[def]]></title><link>area/스프링/thymeleaf/space/def.html</link><guid isPermaLink="false">Area/스프링/thymeleaf/space/def.json</guid><pubDate>Wed, 17 Sep 2025 05:06:11 GMT</pubDate></item><item><title><![CDATA[def]]></title><link>area/스프링/검증/검증-구현(일반)/space/def.html</link><guid isPermaLink="false">Area/스프링/검증/검증 구현(일반)/space/def.json</guid><pubDate>Wed, 17 Sep 2025 04:13:51 GMT</pubDate></item><item><title><![CDATA[def]]></title><link>area/스프링/검증/space/def.html</link><guid isPermaLink="false">Area/스프링/검증/space/def.json</guid><pubDate>Tue, 16 Sep 2025 08:45:05 GMT</pubDate></item><item><title><![CDATA[JPA 란 무엇인가]]></title><description><![CDATA[JPA(Java Persistence API)는 JAVA 애플리케이션과 JDBC 사이에서 동작하는 관리자로객체의 영속성을 관리해주는 역할을 수행한다.자바 ORM 표준 JPA 프로그래밍 - 기본편 섹선 2 보면서 추가 정리 요망]]></description><link>area/스프링/jpa-란-무엇인가.html</link><guid isPermaLink="false">Area/스프링/JPA 란 무엇인가.md</guid><pubDate>Thu, 17 Jul 2025 09:21:33 GMT</pubDate></item><item><title><![CDATA[초기 설정 spring initializer 을 이용한]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://start.spring.io/" target="_self">https://start.spring.io/</a><br><img alt="Pasted image 20250707191531.png" src="archive/media/pasted-image-20250707191531.png" target="_self">]]></description><link>area/스프링/초기-설정-spring-initializer-을-이용한.html</link><guid isPermaLink="false">Area/스프링/초기 설정 spring initializer 을 이용한.md</guid><pubDate>Mon, 07 Jul 2025 10:15:33 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[IntelliJ 유용한 단축키(windows 기준)]]></title><description><![CDATA[CTRL + ALT + v : 입력값이 있을 때 변수 생성]]></description><link>area/스프링/intellij-유용한-단축키(windows-기준).html</link><guid isPermaLink="false">Area/스프링/IntelliJ 유용한 단축키(windows 기준).md</guid><pubDate>Mon, 07 Jul 2025 09:40:34 GMT</pubDate></item><item><title><![CDATA[낙서장임]]></title><description><![CDATA[스프링의 핵심 개념
객체 기반 언어인 자바 기반 프레임워크
좋은 객체 기반 애플리케이션을 개발할 수 있게 지원좋은 객체 지향 프로그래밍이란?
코드를 갈아 끼우듯이
컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법으로
역할과 구현으로 세상을 구분클라이언트는 자동차의 내부 구조를 알 필요가 없음
대상의 내용을 주지 않고 추가 기능을 제공할 수 있다
예를 들어]]></description><link>area/스프링/낙서장임.html</link><guid isPermaLink="false">Area/스프링/낙서장임.md</guid><pubDate>Mon, 07 Jul 2025 06:27:56 GMT</pubDate></item><item><title><![CDATA[왜 스프링인가]]></title><description><![CDATA[스프링은 <a class="internal-link" data-href="객체 지향 프로그래밍이란" href="area/스프링/객체-지향-프로그래밍이란.html" target="_self" rel="noopener nofollow">객체 지향 프로그래밍</a>을 위해 탄생한 <a class="internal-link" data-href="프레임워크 vs 라이브러리" href="area/스프링/프레임워크-vs-라이브러리.html" target="_self" rel="noopener nofollow">프레임워크</a>로
좋은 객체 기반 애플리케이션을 개발하는데 특화되어 있다.<br>스프링은 의존관계 주입 (Dependency injection,DI) 컨테이너를 제공해 <a class="internal-link" data-href="SOLID 좋은 객체 지향 설계를 위한 5 원칙" href="area/스프링/solid-좋은-객체-지향-설계를-위한-5-원칙.html" target="_self" rel="noopener nofollow">OCP, DIP</a>를 가능하게 지원한다.
이를 통해 클라이언트 코드의 변경 없이 확장할 수 있다.]]></description><link>area/스프링/왜-스프링인가.html</link><guid isPermaLink="false">Area/스프링/왜 스프링인가.md</guid><pubDate>Mon, 07 Jul 2025 06:24:33 GMT</pubDate></item><item><title><![CDATA[프레임워크 vs 라이브러리]]></title><description><![CDATA[프레임워크는 내가 작성한 코드를 제어하고 대신 실행(ex. JUnit)
라이브러리는 내가 작성한 코드가 직접 제어의 흐름을 담당(ex. PyTorch)]]></description><link>area/스프링/프레임워크-vs-라이브러리.html</link><guid isPermaLink="false">Area/스프링/프레임워크 vs 라이브러리.md</guid><pubDate>Mon, 07 Jul 2025 05:55:11 GMT</pubDate></item><item><title><![CDATA[객체 지향 프로그래밍이란]]></title><description><![CDATA[컴퓨터 부품을 갈아 끼우듯이(ex. ssd or hhd)
프로그래밍을 할 때 컴포넌트를(여러 기능) 쉽고 유연하게 변경할 수 있도록 개발하는 방식<img alt="제목 없는 다이어그램.drawio 2.png" src="archive/media/제목-없는-다이어그램.drawio-2.png" target="_self" style="width: 650px; max-width: 100%;">역할(인터페이스)과 구현(클래스)로 기능을 분리해 구현클라이언트(다른 기능)는 인터페이스를 통해 어떤 기능을 받나 알 수 있으나 어떻게 받는지는 알 필요가 없음
예를 들어 사용자 데이터를 받을 때 데이터베이스에서 받는가 임시로 직접 입력받은 데이터인지 알 필!요가 없다.기능은 자기 자신의 기능만 책임지면 되고, 클라이언트에 영향을 주지 않고 추가적인 수정을 할 수 있음가장 중요하게 생각하여야 할 것은 인터페이스의 변화가 없게 설계를 해야 한다
인터페이스가 변하면 그 하위 모든 기능을 뒤집어엎어야 하기 때문이다.<br>좋은 객체 지향 설계를 위한 원칙이 <a class="internal-link" data-href="SOLID 좋은 객체 지향 설계를 위한 5원칙" href=".html" target="_self" rel="noopener nofollow">SOLID</a>다객체 지향의 핵심은 다형성이나 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발을 할 수 없다.
왜냐하면 구현 객체를 변경할 때 클라이언트 코드도 변경되기 때문이다
즉 OCP, DIP를 지킬 수 없다.<br>
<a class="internal-link" data-href="조립, 설정자란 무엇인가" href="area/스프링/조립,-설정자란-무엇인가.html" target="_self" rel="noopener nofollow">무언가 더 필요하다.</a>]]></description><link>area/스프링/객체-지향-프로그래밍이란.html</link><guid isPermaLink="false">Area/스프링/객체 지향 프로그래밍이란.md</guid><pubDate>Sat, 05 Jul 2025 08:59:24 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SOLID 좋은 객체 지향 설계를 위한 5 원칙]]></title><description><![CDATA[ 단일 책임 원칙 (Single Responsibility Principle, SRP)
한 클래스는 하나의 책임만 가져야 한다
하나의 책임이라는 모호한 말은 문맥과 상황에 따라 다르게 적용된다
중요한 것은 변경이 있을 때 파급이 적어야 한다는 것이다
예를 들어 할인 정책 등을 변경했는데 SQL 코드가 변해야 한다면 원칙을 지키지 못하였다고 할 수 있다. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다
다형성을 이용하면 수정을 하지 않고 확장을 해야 한다는 이상한 법칙을 지킬 수 있다.
즉 인터페이스를 구현한 새 클래스를 만들어서 새로운 기능을 구현
하지만 이 방법을 적용하면 OCP를 지키지 못하는 경우가 생긴다
OCP를 지키기 위해 객체를 설정하고 관계를 맺어주는 별도의 <a class="internal-link" data-href="조립, 설정자란 무엇인가" href="area/스프링/조립,-설정자란-무엇인가.html" target="_self" rel="noopener nofollow">조립, 설정자</a>가 필요하다 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
기능적으로 규약을 보장해야 한다는 의미로
예를 들어 자동차 인터페이스의 엑셀은 동력을 제동하는 기능으로 타 기능으로 구현(와이퍼 작동)하면 안 된다는 의미이다. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스보다 낫다
예를 들어 자동차 인터페이스를 운전, 정비, 속도계 등등의 인터페이스들로 분리하면 정비 인터페이스가 변해도 타 인터페이스에 영향이 가지 않는다
인터페이스를 분리하며 명확해지고 대체 가능성이 높아짐 의존관계 역전 원칙 (Dependency Inversion Principle, DIP)
프로그래머는 추상화에 의존해야지 구체화에 의존해선 안 된다
클라이언트 코드가 구현 클래스를 알고 있으면 이 원칙을 준수하지 않은 것
아래 사진은 클라이언트 코드가 추상화에도 의존하고 있고 구체화에도 의존하고 있다<br>
<img alt="제목 없는 다이어그램.drawio.png" src="archive/media/제목-없는-다이어그램.drawio.png" target="_self" style="width: 600px; max-width: 100%;"> ]]></description><link>area/스프링/solid-좋은-객체-지향-설계를-위한-5-원칙.html</link><guid isPermaLink="false">Area/스프링/SOLID 좋은 객체 지향 설계를 위한 5 원칙.md</guid><pubDate>Sat, 05 Jul 2025 08:57:32 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[조립, 설정자란 무엇인가]]></title><link>area/스프링/조립,-설정자란-무엇인가.html</link><guid isPermaLink="false">Area/스프링/조립, 설정자란 무엇인가.md</guid><pubDate>Sat, 05 Jul 2025 06:53:53 GMT</pubDate></item><item><title><![CDATA[def]]></title><link>area/스프링/space/def.html</link><guid isPermaLink="false">Area/스프링/space/def.json</guid><pubDate>Fri, 13 Jun 2025 08:34:27 GMT</pubDate></item><item><title><![CDATA[알고리즘 공부]]></title><description><![CDATA[<a data-href="공부" href=".html" class="internal-link" target="_self" rel="noopener nofollow">공부</a><a data-href="알고리즘 공부" href="area/알고리즘-공부/알고리즘-공부.html" class="internal-link" target="_self" rel="noopener nofollow">알고리즘 공부</a>]]></description><link>area/알고리즘-공부/알고리즘-공부.html</link><guid isPermaLink="false">Area/알고리즘 공부/알고리즘 공부.md</guid><pubDate>Fri, 13 Jun 2025 08:34:17 GMT</pubDate></item><item><title><![CDATA[자료구조]]></title><description><![CDATA[<a data-href="알고리즘 공부" href="area/알고리즘-공부/알고리즘-공부.html" class="internal-link" target="_self" rel="noopener nofollow">알고리즘 공부</a>]
자료구조는 데이터를 저장하고 관리하는 방법과 구조를 의미
데이터를 효율적으로 접근하고 수정하기 위한 구조
배열, 리스트, 스택, 큐, 트리, 그래프, 해시 테이블 등의 구조가 있음! 파이썬의 리스트는 배열이 아니다배열을 같은 데이터 타입의 값을 연속된 메모리 공간에 저장하는 자료구조
연속된 메모리 상에 요소가 저장되기 때문에 접근이 빠름
삽입과 삭제가 효율적이지 않고 배열의 크기를 변경할 수 없음]]></description><link>area/알고리즘-공부/자료구조.html</link><guid isPermaLink="false">Area/알고리즘 공부/자료구조.md</guid><pubDate>Fri, 13 Jun 2025 08:34:17 GMT</pubDate></item><item><title><![CDATA[알고리즘]]></title><description><![CDATA[<a data-href="알고리즘 공부" href="area/알고리즘-공부/알고리즘-공부.html" class="internal-link" target="_self" rel="noopener nofollow">알고리즘 공부</a>알고리즘은 주어진 문제를 해결하기 위한 절차난 단계의 집합임
문제 해결을 위한 논리적인 단계를 제공하고, 최적의 결과를 도출하기 위한 방법론
정렬, 탐색, 그래프 알고리즘, 동적 계획법, 분할 정복, 탐욕, 백트래킹 등의 구조가 있음정렬은 배열의 요소를 값의 크기순으로 나열시키는 알고리즘이다.삽입 정렬 : 배열의 모든 요소를 앞에서부터 이미 정렬된 배열의 부분과 비교해 자신의 위치에 삽입해 정렬하는 알고리즘
선택 정렬 : 배열의 모든 요소를 검사해 가장 작은 값을 위치한 값과 교채하는 것을 반복해 정렬하는 알고리즘
버블 정렬 : 서로 인접한 두 원소를 비교하고 서로 교체하는 것을 반복해 정렬하는 알고리즘
셸 정렬 : 멀리 떨어진 요소(처음 시작할 때 간격은 배열의 1/2)들끼리 비교하며 정렬을 진행한 뒤 점차 간격을 줄여나가서 정렬하는 알고리즘
퀵 정렬 : (분할과 정복) 하나의 리스트를 피벗을 기준으로 분할하고 분할한 부분을 정렬하고 정렬한 리스트를 합해 정렬하는 알고리즘
힙 정렬 : 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 알고리즘
병합 정렬 : 하나의 리스트를 분할한 다음 정렬 2개의 정렬된 리스트를 합해 전체가 정렬된 리스트가 되게 하는 알고리즘<br>
<img alt="Pasted image 20241027171659.png" src="archive/media/pasted-image-20241027171659.png" target="_self" style="width: 475px; max-width: 100%;"><br><img alt="Pasted image 20241028170514.png" src="archive/media/pasted-image-20241028170514.png" target="_self" style="width: 400px; max-width: 100%;"><img alt="Pasted image 20241028170526.png" src="archive/media/pasted-image-20241028170526.png" target="_self" style="width: 400px; max-width: 100%;"><img alt="Pasted image 20241028170540.png" src="archive/media/pasted-image-20241028170540.png" target="_self" style="width: 400px; max-width: 100%;">
ㅇㅁㄴㅇ]]></description><link>area/알고리즘-공부/알고리즘.html</link><guid isPermaLink="false">Area/알고리즘 공부/알고리즘.md</guid><pubDate>Fri, 13 Jun 2025 08:34:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[파이썬 커스텀 정렬]]></title><description><![CDATA[#2. 정렬에 사용할 키를 반환하는 함수를 정의하여 정렬하는 방법 1def getKey(e):2	return e[1] 3	4students.sort(key=getKey) 5# key parameter에 키를 반환하는 함수명을 argument로 대입한다. 6sorted_students = sorted(students, key=getKey)1sys.setrecursionlimit(10**6) 2# 파이썬 재귀 풀떄 써야함 안쓰면 제약 걸림(1000개)1import sys23sys.setrecursionlimit(10**6)4input = sys.stdin.readline56n, m = map(int, input().split())78# 정방향 역방향 길 생성9graph = [[] for _ in range(n+1)]10graph_r = [[] for _ in range(n+1)]11for _ in range(m):12 s, t = map(int, input().split())13 graph[s].append(t)14 graph_r[t].append(s)1516S, T = map(int, input().split())1718def dfs(node, graph, visited):19 if visited[node]:20 return21 visited[node] = True22 for nxt in graph[node]:23 dfs(nxt, graph, visited)2425# 출근길: S에서 T로 가는 경로 (T에 도달하면 더 이상 진행하지 않음)26visited1 = [False] * (n+1)27visited1[T] = True # T 도착 시 더 이상 진행하지 않도록 미리 표시28dfs(S, graph, visited1)2930# 출근길: 역방향 그래프 T에서 S로 가는 경로 (S에서 멈춤)31visited1_r = [False] * (n+1)32dfs(T, graph_r, visited1_r)3334# 퇴근길: T에서 S로 가는 경로 (S에 도달하면 더 이상 진행하지 않음)35visited2 = [False] * (n+1)36visited2[S] = True # S 도착 시 더 이상 진행하지 않도록 미리 표시37dfs(T, graph, visited2)3839# 퇴근길: 역방향 그래프 S에서 T로 가는 경로 (T에서 멈춤)40visited2_r = [False] * (n+1)41dfs(S, graph_r, visited2_r)4243answer = 044for i in range(1, n+1):45 if i == S or i == T:46 continue47 if visited1[i] and visited1_r[i] and visited2[i] and visited2_r[i]:48 answer += 14950print(answer)51dfs1import sys2sys.setrecursionlimit(10000)3input = sys.stdin.readline45n = int(input().strip())67# 지도 정보 읽기: 'stat'는 n x n 2차원 리스트로 구성8stat = []9for _ in range(n):10 # 한 줄의 문자열을 정수 리스트로 변환하여 저장11 stat.append(list(map(int, list(input().strip()))))1213# 방문 여부를 저장할 2차원 리스트14visited = [[False] * n for _ in range(n)]1516print(visited)1718# 네 방향 (상, 하, 좌, 우)19dx = [-1, 1, 0, 0]20dy = [0, 0, -1, 1]2122def dfs(x, y):23 """(x, y) 좌표에서 시작하여 연결된 장애물의 개수를 DFS로 반환한다."""24 visited[x][y] = True25 count = 1 # 현재 장애물 포함26 for d in range(4):27 nx = x + dx[d]28 ny = y + dy[d]29 if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; n:30 if stat[nx][ny] == 1 and not visited[nx][ny]:31 count += dfs(nx, ny)32 return count3334result = [] # 각 블록(단지)에 속하는 장애물의 개수를 저장할 리스트3536# 전체 지도를 순회하며 아직 방문하지 않은 장애물(1)을 발견하면 DFS 실행37for i in range(n):38 for j in range(n):39 if stat[i][j] == 1 and not visited[i][j]:40 result.append(dfs(i, j))4142# 결과를 오름차순 정렬 후 출력43result.sort()44print(len(result))45for count in result:46 print(count)47BFS1import sys2from collections import deque3sys.setrecursionlimit(10000)4input = sys.stdin.readline56n = int(input().strip())78# 지도 정보 읽기: 'stat'는 n x n 2차원 리스트로 구성9stat = []10for _ in range(n):11 # 한 줄의 문자열을 정수 리스트로 변환하여 저장12 stat.append(list(map(int, list(input().strip()))))1314# 방문 여부를 저장할 2차원 리스트15visited = [[False] * n for _ in range(n)]1617# print(visited) # 초기 방문 리스트 출력 (디버깅용)1819# 네 방향 (상, 하, 좌, 우)20dx = [-1, 1, 0, 0]21dy = [0, 0, -1, 1]2223def bfs(x, y):24 """(x, y) 좌표에서 시작하여 연결된 장애물의 개수를 BFS로 반환한다."""25 queue = deque()26 queue.append((x, y))27 visited[x][y] = True28 count = 1 # 현재 장애물 포함29 while queue:30 cx, cy = queue.popleft()31 for d in range(4):32 nx = cx + dx[d]33 ny = cy + dy[d]34 if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; n:35 if stat[nx][ny] == 1 and not visited[nx][ny]:36 visited[nx][ny] = True37 queue.append((nx, ny))38 count += 139 return count4041result = [] # 각 블록(단지)에 속하는 장애물의 개수를 저장할 리스트4243# 전체 지도를 순회하며 아직 방문하지 않은 장애물(1)을 발견하면 BFS 실행44for i in range(n):45 for j in range(n):46 if stat[i][j] == 1 and not visited[i][j]:47 result.append(bfs(i, j))4849# 결과를 오름차순 정렬 후 출력50result.sort()51print(len(result))52for count in result:53 print(count)54]]></description><link>area/알고리즘-공부/파이썬-커스텀-정렬.html</link><guid isPermaLink="false">Area/알고리즘 공부/파이썬 커스텀 정렬.md</guid><pubDate>Thu, 10 Apr 2025 07:30:40 GMT</pubDate></item><item><title><![CDATA[순열생성기]]></title><description><![CDATA[1 def gen_permutations(arr, n):2 result = []34 if n == 0:5 return [[]]67 for i, elem in enumerate(arr): 8 for P in gen_permutations(arr[:i] + arr[i+1:], n-1):9 result += [[elem]+P]10 return result]]></description><link>area/알고리즘-공부/순열생성기.html</link><guid isPermaLink="false">Area/알고리즘 공부/순열생성기.md</guid><pubDate>Thu, 10 Apr 2025 07:30:22 GMT</pubDate></item><item><title><![CDATA[소수(채 방식)]]></title><description><![CDATA[1 prime_list = [False, False] + [True] * (maxnum - 1)2 for i in range(2, int(maxnum ** 0.5) + 1):3 if prime_list[i]:4 prime_list[i * 2::i] = [False] * len(prime_list[i * 2::i])1# prime_list=set(range(2,maxnum+1))2# for i in range(2, maxnum+1):3# if i in range(2, maxnum+1):4# prime_list -= set(range(2*i, maxnum+1, i))]]></description><link>area/알고리즘-공부/소수(채-방식).html</link><guid isPermaLink="false">Area/알고리즘 공부/소수(채 방식).md</guid><pubDate>Thu, 10 Apr 2025 07:30:17 GMT</pubDate></item><item><title><![CDATA[lasy heap 중간 요소 삭제 가능]]></title><description><![CDATA[1class LazyHeap:2 def __init__(self):3 self.heap = [] # 실제 힙으로 사용할 리스트4 self.deleted = {} # 삭제되어야 할 요소를 마킹할 딕셔너리56 def push(self, item):7 """힙에 요소 삽입"""8 heapq.heappush(self.heap, item)910 def lazy_delete(self, item):11 """요소를 바로 삭제하지 않고, 삭제 마킹"""12 # if item not in self.deleted:13 # self.deleted[item] = 014 # self.deleted[item] = self.deleted[item] + 115 self.deleted[item] = self.deleted.get(item, 0) + 11617 def pop(self):18 """19 힙의 최솟값을 반환.20 만약 최솟값이 삭제되어야 할 요소라면, 삭제 마킹을 감소시키고21 실제로 유효한 값을 찾을 때까지 pop을 반복.22 """23 while self.heap:24 item = heapq.heappop(self.heap)25 if self.deleted.get(item, 0) &gt; 0:26 # 삭제되어야 하는 요소이면, 삭제 마킹 감소27 self.deleted[item] -= 128 if self.deleted[item] == 0:29 del self.deleted[item]30 continue # 삭제된 요소는 반환하지 않고 건너뛰기31 return item32 raise IndexError("pop from empty heap")]]></description><link>area/알고리즘-공부/lasy-heap-중간-요소-삭제-가능.html</link><guid isPermaLink="false">Area/알고리즘 공부/lasy heap 중간 요소 삭제 가능.md</guid><pubDate>Thu, 10 Apr 2025 07:30:01 GMT</pubDate></item><item><title><![CDATA[코딩 사이트별 난이도]]></title><description><![CDATA[<img alt="Pasted image 20250319173718.png" src="archive/media/pasted-image-20250319173718.png" target="_self">]]></description><link>area/알고리즘-공부/코딩-사이트별-난이도.html</link><guid isPermaLink="false">Area/알고리즘 공부/코딩 사이트별 난이도.md</guid><pubDate>Wed, 19 Mar 2025 08:37:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[index]]></title><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Fri, 19 Sep 2025 09:53:20 GMT</pubDate></item></channel></rss>